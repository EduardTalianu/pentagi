//go:build ignore
// +build ignore

package main

import (
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
)

// FileMetadata represents metadata for embedded files
type FileMetadata struct {
	Path   string `json:"path"`
	Size   int64  `json:"size"`
	SHA256 string `json:"sha256"`
	Mode   uint32 `json:"mode"`
}

// MetadataFile contains all file metadata
type MetadataFile struct {
	Files map[string]FileMetadata `json:"files"`
}

func main() {
	linksDir := "links"

	// check if links directory exists
	if _, err := os.Stat(linksDir); os.IsNotExist(err) {
		log.Printf("Links directory '%s' not found, skipping generation", linksDir)
		return
	}

	// read all files and directories in links directory
	entries, err := os.ReadDir(linksDir)
	if err != nil {
		log.Fatal(err)
	}

	var embedFiles []string
	var fileContents = make(map[string]string)
	metadata := MetadataFile{Files: make(map[string]FileMetadata)}

	for _, entry := range entries {
		entryPath := filepath.Join(linksDir, entry.Name())

		// follow symlinks to determine actual file type
		info, err := os.Stat(entryPath)
		if err != nil {
			log.Printf("Warning: could not stat %s: %v", entryPath, err)
			continue
		}

		if info.IsDir() {
			// process directory recursively
			// resolve symlink to get real directory path
			realPath, err := filepath.EvalSymlinks(entryPath)
			if err != nil {
				log.Printf("Warning: could not resolve symlink %s: %v", entryPath, err)
				continue
			}

			err = filepath.Walk(realPath, func(path string, walkInfo os.FileInfo, err error) error {
				if err != nil {
					return err
				}

				// skip directories themselves, only process files
				if walkInfo.IsDir() {
					return nil
				}

				// skip system files
				if filepath.Base(path) == ".DS_Store" {
					return nil
				}

				// get relative path from real directory root
				relPathFromReal, err := filepath.Rel(realPath, path)
				if err != nil {
					return err
				}

				// construct relative path as it should appear in embedded fs
				relPath := filepath.Join(entry.Name(), relPathFromReal)

				embedFiles = append(embedFiles, relPath)
				content, fileMeta, err := readFileContentWithMetadata(path)
				if err != nil {
					return err
				}
				fileContents[relPath] = content
				fileMeta.Path = relPath
				metadata.Files[relPath] = fileMeta

				return nil
			})
			if err != nil {
				log.Fatal(err)
			}
		} else {
			// process file
			embedFiles = append(embedFiles, entry.Name())
			content, fileMeta, err := readFileContentWithMetadata(entryPath)
			if err != nil {
				log.Printf("Warning: could not read file %s: %v", entryPath, err)
				continue
			}
			fileContents[entry.Name()] = content
			fileMeta.Path = entry.Name()
			metadata.Files[entry.Name()] = fileMeta
		}
	}

	// generate Go code for embedded provider
	output := `// Code generated by go generate; DO NOT EDIT.

package files

import (
	"crypto/sha256"
	"embed"
	"encoding/json"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

//go:embed fs/*
var embeddedFS embed.FS

// FileMetadata represents metadata for embedded files
type FileMetadata struct {
	Path   string ` + "`" + `json:"path"` + "`" + `
	Size   int64  ` + "`" + `json:"size"` + "`" + `
	SHA256 string ` + "`" + `json:"sha256"` + "`" + `
    Mode   uint32 ` + "`" + `json:"mode"` + "`" + `
}

// MetadataFile contains all file metadata
type MetadataFile struct {
	Files map[string]FileMetadata ` + "`" + `json:"files"` + "`" + `
}

// embeddedProvider implements EmbeddedProvider interface
type embeddedProviderImpl struct{
	metadata *MetadataFile
}

func init() {
	ep := &embeddedProviderImpl{}
	
	// load metadata
	if metaContent, err := embeddedFS.ReadFile("fs/.meta.json"); err == nil {
		var meta MetadataFile
		if err := json.Unmarshal(metaContent, &meta); err == nil {
			ep.metadata = &meta
		}
	}
	
	embeddedProvider = ep
}

// GetContent returns file content from embedded filesystem
func (ep *embeddedProviderImpl) GetContent(name string) ([]byte, error) {
	return embeddedFS.ReadFile(filepath.Join("fs", name))
}

// Exists checks if file/directory exists in embedded filesystem
func (ep *embeddedProviderImpl) Exists(name string) bool {
	_, err := fs.Stat(embeddedFS, filepath.Join("fs", name))
	return err == nil
}

// Stat returns file info from embedded filesystem
func (ep *embeddedProviderImpl) Stat(name string) (fs.FileInfo, error) {
	return fs.Stat(embeddedFS, filepath.Join("fs", name))
}

// Copy copies file/directory from embedded FS to real filesystem
func (ep *embeddedProviderImpl) Copy(src, dst string, rewrite bool) error {
	srcPath := filepath.Join("fs", src)
	dstPath := filepath.Join(dst, src)
	
	info, err := fs.Stat(embeddedFS, srcPath)
	if err != nil {
		return err
	}
	
	if info.IsDir() {
		return ep.copyDirFromEmbed(srcPath, dstPath, rewrite)
	}
	
	return ep.copyFileFromEmbed(srcPath, dstPath, rewrite)
}

// copyFileFromEmbed copies single file from embedded FS using streaming
func (ep *embeddedProviderImpl) copyFileFromEmbed(src, dst string, rewrite bool) error {
	if !rewrite {
		if _, err := os.Stat(dst); err == nil {
			return &os.PathError{Op: "copy", Path: dst, Err: os.ErrExist}
		}
	}
	
	// ensure destination directory exists
	if err := os.MkdirAll(filepath.Dir(dst), 0755); err != nil {
		return err
	}
	
	// open embedded file for streaming
	srcFile, err := embeddedFS.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()
	
	// create destination file
	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()
	
	// stream copy without loading full file into memory
	_, err = io.Copy(dstFile, srcFile)
    if err != nil {
        return err
    }

    // apply permissions if metadata available
    if ep.metadata != nil {
        // src has prefix "fs/"; strip to get metadata key
        rel := strings.TrimPrefix(src, "fs/")
        if meta, ok := ep.metadata.Files[rel]; ok {
            if chmodErr := os.Chmod(dst, fs.FileMode(meta.Mode)); chmodErr != nil {
                return chmodErr
            }
        }
    }

    return nil
}

// copyDirFromEmbed copies directory recursively from embedded FS
func (ep *embeddedProviderImpl) copyDirFromEmbed(src, dst string, rewrite bool) error {
	if !rewrite {
		if _, err := os.Stat(dst); err == nil {
			return &os.PathError{Op: "copy", Path: dst, Err: os.ErrExist}
		}
	}
	
	return fs.WalkDir(embeddedFS, src, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		
		relPath, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}
		
		dstPath := filepath.Join(dst, relPath)
		
		if d.IsDir() {
			return os.MkdirAll(dstPath, 0755)
		}
		
		return ep.copyFileFromEmbed(path, dstPath, rewrite)
	})
}

// List returns all embedded files with given prefix
func (ep *embeddedProviderImpl) List(prefix string) ([]string, error) {
	var files []string
	
	err := fs.WalkDir(embeddedFS, "fs", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		
		// skip directories
		if d.IsDir() {
			return nil
		}
		
		// get relative path from fs directory
		relPath, err := filepath.Rel("fs", path)
		if err != nil {
			return err
		}
		
		// normalize path separators for consistency
		relPath = filepath.ToSlash(relPath)
		
		// check if path starts with prefix
		if prefix == "" || strings.HasPrefix(relPath, prefix) {
			files = append(files, relPath)
		}
		
		return nil
	})
	
	return files, err
}

// CheckHash compares file hash with embedded metadata
func (ep *embeddedProviderImpl) CheckHash(name, workingDir string) (bool, error) {
	if ep.metadata == nil {
		return false, fmt.Errorf("no metadata available")
	}
	
	meta, exists := ep.metadata.Files[name]
	if !exists {
		return false, fmt.Errorf("file not found in metadata")
	}
	
	targetPath := filepath.Join(workingDir, name)
	
	// check file size first (quick check)
	fsInfo, err := os.Stat(targetPath)
	if err != nil {
		return false, err
	}
	
	if fsInfo.Size() != meta.Size {
		return false, nil // different size, definitely different
	}
	
	// calculate hash of filesystem file
	fsFile, err := os.Open(targetPath)
	if err != nil {
		return false, err
	}
	defer fsFile.Close()
	
	hash := sha256.New()
	if _, err := io.Copy(hash, fsFile); err != nil {
		return false, err
	}
	
	fsHash := fmt.Sprintf("%x", hash.Sum(nil))
	return fsHash == meta.SHA256, nil
}

// ExpectedMode returns expected permission bits for a file from metadata
func (ep *embeddedProviderImpl) ExpectedMode(name string) (fs.FileMode, bool) {
    if ep.metadata == nil {
        return 0, false
    }
    meta, ok := ep.metadata.Files[name]
    if !ok {
        return 0, false
    }
    return fs.FileMode(meta.Mode), true
}
`

	// create fs directory
	err = os.MkdirAll("fs", 0755)
	if err != nil {
		log.Fatal(err)
	}

	// copy file contents to fs directory
	for filename, content := range fileContents {
		destPath := filepath.Join("fs", filename)

		// create directories if needed
		err = os.MkdirAll(filepath.Dir(destPath), 0755)
		if err != nil {
			log.Fatal(err)
		}

		err = os.WriteFile(destPath, []byte(content), 0644)
		if err != nil {
			log.Fatal(err)
		}

		// apply source file permissions if present
		if meta, ok := metadata.Files[filename]; ok {
			if chmodErr := os.Chmod(destPath, os.FileMode(meta.Mode)); chmodErr != nil {
				log.Fatal(chmodErr)
			}
		}
	}

	// write metadata file
	metadataContent, err := json.MarshalIndent(metadata, "", "  ")
	if err != nil {
		log.Fatal(err)
	}

	metaPath := filepath.Join("fs", ".meta.json")
	err = os.WriteFile(metaPath, metadataContent, 0644)
	if err != nil {
		log.Fatal(err)
	}

	// write generated Go code
	err = os.WriteFile("fs.go", []byte(output), 0644)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated embedded files for: %v\n", embedFiles)
}

func readFileContentWithMetadata(filename string) (string, FileMetadata, error) {
	file, err := os.Open(filename)
	if err != nil {
		return "", FileMetadata{}, err
	}
	defer file.Close()

	// get file info for size
	info, err := file.Stat()
	if err != nil {
		return "", FileMetadata{}, err
	}

	// calculate hash while reading content
	hash := sha256.New()
	teeReader := io.TeeReader(file, hash)

	content, err := io.ReadAll(teeReader)
	if err != nil {
		return "", FileMetadata{}, err
	}

	meta := FileMetadata{
		Size:   info.Size(),
		SHA256: fmt.Sprintf("%x", hash.Sum(nil)),
		Mode:   uint32(info.Mode().Perm()),
	}

	return string(content), meta, nil
}
