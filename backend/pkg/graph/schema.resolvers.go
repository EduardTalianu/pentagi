package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.57

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"pentagi/pkg/controller"
	"pentagi/pkg/database"
	"pentagi/pkg/database/converter"
	"pentagi/pkg/graph/model"
	"pentagi/pkg/providers/anthropic"
	"pentagi/pkg/providers/bedrock"
	"pentagi/pkg/providers/gemini"
	"pentagi/pkg/providers/openai"
	"pentagi/pkg/providers/pconfig"
	"pentagi/pkg/providers/provider"
	"pentagi/pkg/templates"
	"pentagi/pkg/templates/validator"
	"time"

	"github.com/sirupsen/logrus"
)

// CreateFlow is the resolver for the createFlow field.
func (r *mutationResolver) CreateFlow(ctx context.Context, modelProvider string, input string) (*model.Flow, error) {
	uid, _, err := validatePermission(ctx, "flows.create")
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":      uid,
		"provider": modelProvider,
		"input":    input,
	}).Debug("create flow")

	if modelProvider == "" {
		return nil, fmt.Errorf("model provider is required")
	}

	if input == "" {
		return nil, fmt.Errorf("user input is required")
	}

	prvname := provider.ProviderName(modelProvider)
	prv, err := r.ProvidersCtrl.GetProvider(ctx, prvname, uid)
	if err != nil {
		return nil, err
	}
	prvtype := prv.Type()

	fw, err := r.Controller.CreateFlow(ctx, uid, input, prvname, prvtype, nil)
	if err != nil {
		return nil, err
	}

	flow, err := r.DB.GetFlow(ctx, fw.GetFlowID())
	if err != nil {
		return nil, err
	}

	var containers []database.Container
	if _, _, err = validatePermission(ctx, "containers.view"); err == nil {
		containers, err = r.DB.GetFlowContainers(ctx, fw.GetFlowID())
		if err != nil {
			return nil, err
		}
	}

	return converter.ConvertFlow(flow, containers), nil
}

// PutUserInput is the resolver for the putUserInput field.
func (r *mutationResolver) PutUserInput(ctx context.Context, flowID int64, input string) (model.ResultType, error) {
	uid, err := validatePermissionWithFlowID(ctx, "flows.edit", flowID, r.DB)
	if err != nil {
		return model.ResultTypeError, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("put user input")

	fw, err := r.Controller.GetFlow(ctx, flowID)
	if err != nil {
		return model.ResultTypeError, err
	}

	if err := fw.PutInput(ctx, input); err != nil {
		return model.ResultTypeError, err
	}

	return model.ResultTypeSuccess, nil
}

// StopFlow is the resolver for the stopFlow field.
func (r *mutationResolver) StopFlow(ctx context.Context, flowID int64) (model.ResultType, error) {
	uid, err := validatePermissionWithFlowID(ctx, "flows.edit", flowID, r.DB)
	if err != nil {
		return model.ResultTypeError, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("stop flow")

	if err := r.Controller.StopFlow(ctx, flowID); err != nil {
		return model.ResultTypeError, err
	}

	return model.ResultTypeSuccess, nil
}

// FinishFlow is the resolver for the finishFlow field.
func (r *mutationResolver) FinishFlow(ctx context.Context, flowID int64) (model.ResultType, error) {
	uid, err := validatePermissionWithFlowID(ctx, "flows.edit", flowID, r.DB)
	if err != nil {
		return model.ResultTypeError, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("finish flow")

	err = r.Controller.FinishFlow(ctx, flowID)
	if err != nil {
		return model.ResultTypeError, err
	}

	return model.ResultTypeSuccess, nil
}

// DeleteFlow is the resolver for the deleteFlow field.
func (r *mutationResolver) DeleteFlow(ctx context.Context, flowID int64) (model.ResultType, error) {
	uid, err := validatePermissionWithFlowID(ctx, "flows.delete", flowID, r.DB)
	if err != nil {
		return model.ResultTypeError, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("delete flow")

	if fw, err := r.Controller.GetFlow(ctx, flowID); err == nil {
		if err := fw.Finish(ctx); err != nil {
			return model.ResultTypeError, err
		}
	} else if !errors.Is(err, controller.ErrFlowNotFound) {
		return model.ResultTypeError, err
	}

	flow, err := r.DB.GetFlow(ctx, flowID)
	if err != nil {
		return model.ResultTypeError, err
	}

	containers, err := r.DB.GetFlowContainers(ctx, flow.ID)
	if err != nil {
		return model.ResultTypeError, err
	}

	if _, err := r.DB.DeleteFlow(ctx, flowID); err != nil {
		return model.ResultTypeError, err
	}

	publisher := r.Subscriptions.NewFlowPublisher(flow.UserID, flow.ID)
	publisher.FlowUpdated(ctx, flow, containers)
	publisher.FlowDeleted(ctx, flow, containers)

	return model.ResultTypeSuccess, nil
}

// CreateAssistant is the resolver for the createAssistant field.
func (r *mutationResolver) CreateAssistant(ctx context.Context, flowID int64, modelProvider string, input string, useAgents bool) (*model.FlowAssistant, error) {
	var (
		err error
		uid int64
	)

	if flowID == 0 {
		uid, _, err = validatePermission(ctx, "assistants.create")
		if err != nil {
			return nil, err
		}
		uid, _, err = validatePermission(ctx, "flows.create")
		if err != nil {
			return nil, err
		}
	} else {
		uid, err = validatePermissionWithFlowID(ctx, "assistants.create", flowID, r.DB)
		if err != nil {
			return nil, err
		}
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":      uid,
		"flow":     flowID,
		"provider": modelProvider,
		"input":    input,
	}).Debug("create assistant")

	if modelProvider == "" {
		return nil, fmt.Errorf("model provider is required")
	}

	if input == "" {
		return nil, fmt.Errorf("user input is required")
	}

	prvname := provider.ProviderName(modelProvider)
	prv, err := r.ProvidersCtrl.GetProvider(ctx, prvname, uid)
	if err != nil {
		return nil, err
	}
	prvtype := prv.Type()

	aw, err := r.Controller.CreateAssistant(ctx, uid, flowID, input, useAgents, prvname, prvtype, nil)
	if err != nil {
		return nil, err
	}

	assistant, err := r.DB.GetAssistant(ctx, aw.GetAssistantID())
	if err != nil {
		return nil, err
	}

	flow, err := r.DB.GetFlow(ctx, assistant.FlowID)
	if err != nil {
		return nil, err
	}

	containers, err := r.DB.GetFlowContainers(ctx, assistant.FlowID)
	if err != nil {
		return nil, err
	}

	return converter.ConvertFlowAssistant(flow, containers, assistant), nil
}

// CallAssistant is the resolver for the callAssistant field.
func (r *mutationResolver) CallAssistant(ctx context.Context, flowID int64, assistantID int64, input string, useAgents bool) (model.ResultType, error) {
	uid, err := validatePermissionWithFlowID(ctx, "assistants.edit", flowID, r.DB)
	if err != nil {
		return model.ResultTypeError, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":       uid,
		"flow":      flowID,
		"assistant": assistantID,
	}).Debug("call assistant")

	fw, err := r.Controller.GetFlow(ctx, flowID)
	if err != nil {
		return model.ResultTypeError, err
	}

	aw, err := fw.GetAssistant(ctx, assistantID)
	if err != nil {
		return model.ResultTypeError, err
	}

	if err := aw.PutInput(ctx, input, useAgents); err != nil {
		return model.ResultTypeError, err
	}

	return model.ResultTypeSuccess, nil
}

// StopAssistant is the resolver for the stopAssistant field.
func (r *mutationResolver) StopAssistant(ctx context.Context, flowID int64, assistantID int64) (*model.Assistant, error) {
	uid, err := validatePermissionWithFlowID(ctx, "assistants.edit", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":       uid,
		"flow":      flowID,
		"assistant": assistantID,
	}).Debug("stop assistant")

	fw, err := r.Controller.GetFlow(ctx, flowID)
	if err != nil {
		return nil, err
	}

	aw, err := fw.GetAssistant(ctx, assistantID)
	if err != nil {
		return nil, err
	}

	if err := aw.Stop(ctx); err != nil {
		return nil, err
	}

	assistant, err := r.DB.GetFlowAssistant(ctx, database.GetFlowAssistantParams{
		ID:     assistantID,
		FlowID: flowID,
	})
	if err != nil {
		return nil, err
	}

	r.Subscriptions.NewFlowPublisher(fw.GetUserID(), flowID).AssistantUpdated(ctx, assistant)

	return converter.ConvertAssistant(assistant), nil
}

// DeleteAssistant is the resolver for the deleteAssistant field.
func (r *mutationResolver) DeleteAssistant(ctx context.Context, flowID int64, assistantID int64) (model.ResultType, error) {
	uid, err := validatePermissionWithFlowID(ctx, "assistants.delete", flowID, r.DB)
	if err != nil {
		return model.ResultTypeError, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":       uid,
		"flow":      flowID,
		"assistant": assistantID,
	}).Debug("delete assistant")

	fw, err := r.Controller.GetFlow(ctx, flowID)
	if err != nil {
		return model.ResultTypeError, err
	}

	assistant, err := r.DB.GetFlowAssistant(ctx, database.GetFlowAssistantParams{
		ID:     assistantID,
		FlowID: flowID,
	})
	if err != nil {
		return model.ResultTypeError, err
	}

	if err := fw.DeleteAssistant(ctx, assistantID); err != nil {
		return model.ResultTypeError, err
	}

	r.Subscriptions.NewFlowPublisher(fw.GetUserID(), flowID).AssistantDeleted(ctx, assistant)

	return model.ResultTypeSuccess, nil
}

// TestAgent is the resolver for the testAgent field.
func (r *mutationResolver) TestAgent(ctx context.Context, typeArg model.ProviderType, agentType model.AgentType, agent model.AgentConfig) (*model.AgentTestResult, error) {
	uid, _, err := validatePermission(ctx, "settings.providers.view")
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"type": typeArg.String(),
	}).Debug("test agent")

	cfg := converter.ConvertAgentConfigFromGqlModel(&agent)
	prvtype := provider.ProviderType(typeArg)
	atype := pconfig.ProviderOptionsType(agentType)
	result, err := r.ProvidersCtrl.TestAgent(ctx, prvtype, atype, cfg)
	if err != nil {
		return nil, err
	}

	return converter.ConvertTestResults(result), nil
}

// TestProvider is the resolver for the testProvider field.
func (r *mutationResolver) TestProvider(ctx context.Context, typeArg model.ProviderType, agents model.AgentsConfig) (*model.ProviderTestResult, error) {
	uid, _, err := validatePermission(ctx, "settings.providers.view")
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"type": typeArg.String(),
	}).Debug("test provider")

	cfg := converter.ConvertAgentsConfigFromGqlModel(&agents)
	prvtype := provider.ProviderType(typeArg)
	result, err := r.ProvidersCtrl.TestProvider(ctx, prvtype, cfg)
	if err != nil {
		return nil, err
	}

	return converter.ConvertProviderTestResults(result), nil
}

// CreateProvider is the resolver for the createProvider field.
func (r *mutationResolver) CreateProvider(ctx context.Context, name string, typeArg model.ProviderType, agents model.AgentsConfig) (*model.ProviderConfig, error) {
	uid, _, err := validatePermission(ctx, "settings.providers.edit")
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"name": name,
		"type": typeArg.String(),
	}).Debug("create provider")

	cfg := converter.ConvertAgentsConfigFromGqlModel(&agents)
	prvname, prvtype := provider.ProviderName(name), provider.ProviderType(typeArg)
	prv, err := r.ProvidersCtrl.CreateProvider(ctx, uid, prvname, prvtype, cfg)
	if err != nil {
		return nil, err
	}

	r.Subscriptions.NewFlowPublisher(uid, 0).ProviderCreated(ctx, prv, cfg)

	return converter.ConvertProvider(prv, cfg), nil
}

// UpdateProvider is the resolver for the updateProvider field.
func (r *mutationResolver) UpdateProvider(ctx context.Context, providerID int64, name string, agents model.AgentsConfig) (*model.ProviderConfig, error) {
	uid, _, err := validatePermission(ctx, "settings.providers.edit")
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":      uid,
		"provider": providerID,
		"name":     name,
	}).Debug("update provider")

	cfg := converter.ConvertAgentsConfigFromGqlModel(&agents)
	prvname := provider.ProviderName(name)
	prv, err := r.ProvidersCtrl.UpdateProvider(ctx, uid, providerID, prvname, cfg)
	if err != nil {
		return nil, err
	}

	r.Subscriptions.NewFlowPublisher(uid, 0).ProviderUpdated(ctx, prv, cfg)

	return converter.ConvertProvider(prv, cfg), nil
}

// DeleteProvider is the resolver for the deleteProvider field.
func (r *mutationResolver) DeleteProvider(ctx context.Context, providerID int64) (model.ResultType, error) {
	uid, _, err := validatePermission(ctx, "settings.providers.edit")
	if err != nil {
		return model.ResultTypeError, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":      uid,
		"provider": providerID,
	}).Debug("delete provider")

	prv, err := r.ProvidersCtrl.DeleteProvider(ctx, uid, providerID)
	if err != nil {
		return model.ResultTypeError, err
	}

	var cfg pconfig.ProviderConfig
	if err := json.Unmarshal(prv.Config, &cfg); err != nil {
		return model.ResultTypeError, err
	}

	r.Subscriptions.NewFlowPublisher(uid, 0).ProviderDeleted(ctx, prv, &cfg)

	return model.ResultTypeSuccess, nil
}

// ValidatePrompt is the resolver for the validatePrompt field.
func (r *mutationResolver) ValidatePrompt(ctx context.Context, typeArg model.PromptType, template string) (*model.PromptValidationResult, error) {
	uid, _, err := validatePermission(ctx, "settings.prompts.edit")
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":      uid,
		"type":     typeArg.String(),
		"template": template[:min(len(template), 1000)],
	}).Debug("validate prompt")

	var (
		result    model.ResultType = model.ResultTypeSuccess
		errorType *model.PromptValidationErrorType
		message   *string
		line      *int
		details   *string
	)

	if err := validator.ValidatePrompt(templates.PromptType(typeArg), template); err != nil {
		result = model.ResultTypeError
		errType := model.PromptValidationErrorTypeUnknownType
		if err, ok := err.(*validator.ValidationError); ok {
			switch err.Type {
			case validator.ErrorTypeSyntax:
				errType = model.PromptValidationErrorTypeSyntaxError
			case validator.ErrorTypeUnauthorizedVar:
				errType = model.PromptValidationErrorTypeUnauthorizedVariable
			case validator.ErrorTypeRenderingFailed:
				errType = model.PromptValidationErrorTypeRenderingFailed
			case validator.ErrorTypeEmptyTemplate:
				errType = model.PromptValidationErrorTypeEmptyTemplate
			case validator.ErrorTypeVariableTypeMismatch:
				errType = model.PromptValidationErrorTypeVariableTypeMismatch
			}
			if err.Message != "" {
				message = &err.Message
			}
			if err.Line > 0 {
				line = &err.Line
			}
			if err.Details != "" {
				details = &err.Details
			}
		}
		errorType = &errType
	}

	return &model.PromptValidationResult{
		Result:    result,
		ErrorType: errorType,
		Message:   message,
		Line:      line,
		Details:   details,
	}, nil
}

// CreatePrompt is the resolver for the createPrompt field.
func (r *mutationResolver) CreatePrompt(ctx context.Context, typeArg model.PromptType, template string) (*model.UserPrompt, error) {
	uid, _, err := validatePermission(ctx, "settings.prompts.edit")
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":      uid,
		"type":     typeArg.String(),
		"template": template[:min(len(template), 1000)],
	}).Debug("create prompt")

	if err := validator.ValidatePrompt(templates.PromptType(typeArg), template); err != nil {
		return nil, err
	}

	prompt, err := r.DB.CreateUserPrompt(ctx, database.CreateUserPromptParams{
		UserID: uid,
		Type:   database.PromptType(typeArg),
		Prompt: template,
	})
	if err != nil {
		return nil, err
	}

	return converter.ConvertPrompt(prompt), nil
}

// UpdatePrompt is the resolver for the updatePrompt field.
func (r *mutationResolver) UpdatePrompt(ctx context.Context, promptID int64, template string) (*model.UserPrompt, error) {
	uid, _, err := validatePermission(ctx, "settings.prompts.edit")
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":      uid,
		"prompt":   promptID,
		"template": template[:min(len(template), 1000)],
	}).Debug("update prompt")

	prompt, err := r.DB.GetUserPrompt(ctx, database.GetUserPromptParams{
		ID:     promptID,
		UserID: uid,
	})
	if err != nil {
		return nil, err
	}

	if err := validator.ValidatePrompt(templates.PromptType(prompt.Type), template); err != nil {
		return nil, err
	}

	prompt, err = r.DB.UpdateUserPrompt(ctx, database.UpdateUserPromptParams{
		ID:     promptID,
		Prompt: template,
		UserID: uid,
	})
	if err != nil {
		return nil, err
	}

	return converter.ConvertPrompt(prompt), nil
}

// DeletePrompt is the resolver for the deletePrompt field.
func (r *mutationResolver) DeletePrompt(ctx context.Context, promptID int64) (model.ResultType, error) {
	uid, _, err := validatePermission(ctx, "settings.prompts.edit")
	if err != nil {
		return model.ResultTypeError, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":    uid,
		"prompt": promptID,
	}).Debug("delete prompt")

	err = r.DB.DeleteUserPrompt(ctx, database.DeleteUserPromptParams{
		ID:     promptID,
		UserID: uid,
	})
	if err != nil {
		return model.ResultTypeError, err
	}

	return model.ResultTypeSuccess, nil
}

// Providers is the resolver for the providers field.
func (r *queryResolver) Providers(ctx context.Context) ([]*model.Provider, error) {
	uid, _, err := validatePermission(ctx, "providers.view")
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid": uid,
	}).Debug("get providers")

	providers, err := r.ProvidersCtrl.GetProviders(ctx, uid)
	if err != nil {
		return nil, err
	}

	providersList := make([]*model.Provider, len(providers))
	for i, prvname := range providers.ListNames() {
		providersList[i] = &model.Provider{
			Name: string(prvname),
			Type: model.ProviderType(providers[prvname].Type()),
		}
	}

	return providersList, nil
}

// Assistants is the resolver for the assistants field.
func (r *queryResolver) Assistants(ctx context.Context, flowID int64) ([]*model.Assistant, error) {
	uid, err := validatePermissionWithFlowID(ctx, "assistants.view", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("get assistants")

	assistants, err := r.DB.GetFlowAssistants(ctx, flowID)
	if err != nil {
		return nil, err
	}

	return converter.ConvertAssistants(assistants), nil
}

// Flows is the resolver for the flows field.
func (r *queryResolver) Flows(ctx context.Context) ([]*model.Flow, error) {
	uid, admin, err := validatePermission(ctx, "flows.view")
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid": uid,
	}).Debug("get flows")

	var (
		flows      []database.Flow
		containers []database.Container
	)

	if admin {
		flows, err = r.DB.GetFlows(ctx)
	} else {
		flows, err = r.DB.GetUserFlows(ctx, uid)
	}
	if err != nil {
		return nil, err
	}

	if _, admin, err = validatePermission(ctx, "containers.view"); err == nil {
		if admin {
			containers, err = r.DB.GetContainers(ctx)
		} else {
			containers, err = r.DB.GetUserContainers(ctx, uid)
		}
		if err != nil {
			return nil, err
		}
	}

	return converter.ConvertFlows(flows, containers), nil
}

// Flow is the resolver for the flow field.
func (r *queryResolver) Flow(ctx context.Context, flowID int64) (*model.Flow, error) {
	uid, err := validatePermissionWithFlowID(ctx, "flows.view", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("get flow")

	var (
		flow       database.Flow
		containers []database.Container
	)

	flow, err = r.DB.GetFlow(ctx, flowID)
	if err != nil {
		return nil, err
	}

	if _, _, err = validatePermission(ctx, "containers.view"); err == nil {
		containers, err = r.DB.GetFlowContainers(ctx, flowID)
		if err != nil {
			return nil, err
		}
	}

	return converter.ConvertFlow(flow, containers), nil
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context, flowID int64) ([]*model.Task, error) {
	uid, err := validatePermissionWithFlowID(ctx, "tasks.view", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("get tasks")

	tasks, err := r.DB.GetFlowTasks(ctx, flowID)
	if err != nil {
		return nil, err
	}

	var subtasks []database.Subtask
	if _, _, err = validatePermission(ctx, "subtasks.view"); err == nil {
		subtasks, err = r.DB.GetFlowSubtasks(ctx, flowID)
		if err != nil {
			return nil, err
		}
	}

	return converter.ConvertTasks(tasks, subtasks), nil
}

// Screenshots is the resolver for the screenshots field.
func (r *queryResolver) Screenshots(ctx context.Context, flowID int64) ([]*model.Screenshot, error) {
	uid, err := validatePermissionWithFlowID(ctx, "screenshots.view", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("get screenshots")

	screenshots, err := r.DB.GetFlowScreenshots(ctx, flowID)
	if err != nil {
		return nil, err
	}

	return converter.ConvertScreenshots(screenshots), nil
}

// TerminalLogs is the resolver for the terminalLogs field.
func (r *queryResolver) TerminalLogs(ctx context.Context, flowID int64) ([]*model.TerminalLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "termlogs.view", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("get term logs")

	logs, err := r.DB.GetFlowTermLogs(ctx, flowID)
	if err != nil {
		return nil, err
	}

	return converter.ConvertTerminalLogs(logs, flowID), nil
}

// MessageLogs is the resolver for the messageLogs field.
func (r *queryResolver) MessageLogs(ctx context.Context, flowID int64) ([]*model.MessageLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "msglogs.view", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("get msg logs")

	logs, err := r.DB.GetFlowMsgLogs(ctx, flowID)
	if err != nil {
		return nil, err
	}

	return converter.ConvertMessageLogs(logs), nil
}

// AgentLogs is the resolver for the agentLogs field.
func (r *queryResolver) AgentLogs(ctx context.Context, flowID int64) ([]*model.AgentLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "agentlogs.view", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("get agent logs")

	logs, err := r.DB.GetFlowAgentLogs(ctx, flowID)
	if err != nil {
		return nil, err
	}

	return converter.ConvertAgentLogs(logs), nil
}

// SearchLogs is the resolver for the searchLogs field.
func (r *queryResolver) SearchLogs(ctx context.Context, flowID int64) ([]*model.SearchLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "searchlogs.view", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("get search logs")

	logs, err := r.DB.GetFlowSearchLogs(ctx, flowID)
	if err != nil {
		return nil, err
	}

	return converter.ConvertSearchLogs(logs), nil
}

// VectorStoreLogs is the resolver for the vectorStoreLogs field.
func (r *queryResolver) VectorStoreLogs(ctx context.Context, flowID int64) ([]*model.VectorStoreLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "vecstorelogs.view", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":  uid,
		"flow": flowID,
	}).Debug("get vector store logs")

	logs, err := r.DB.GetFlowVectorStoreLogs(ctx, flowID)
	if err != nil {
		return nil, err
	}

	return converter.ConvertVectorStoreLogs(logs), nil
}

// AssistantLogs is the resolver for the assistantLogs field.
func (r *queryResolver) AssistantLogs(ctx context.Context, flowID int64, assistantID int64) ([]*model.AssistantLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "assistantlogs.view", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid":       uid,
		"flow":      flowID,
		"assistant": assistantID,
	}).Debug("get assistant logs")

	logs, err := r.DB.GetFlowAssistantLogs(ctx, database.GetFlowAssistantLogsParams{
		FlowID:      flowID,
		AssistantID: assistantID,
	})
	if err != nil {
		return nil, err
	}

	return converter.ConvertAssistantLogs(logs), nil
}

// Settings is the resolver for the settings field.
func (r *queryResolver) Settings(ctx context.Context) (*model.Settings, error) {
	_, _, err := validatePermission(ctx, "settings.view")
	if err != nil {
		return nil, err
	}

	settings := &model.Settings{
		Debug:              r.Config.Debug,
		AskUser:            r.Config.AskUser,
		DockerInside:       r.Config.DockerInside,
		AssistantUseAgents: r.Config.AssistantUseAgents,
	}

	return settings, nil
}

// SettingsProviders is the resolver for the settingsProviders field.
func (r *queryResolver) SettingsProviders(ctx context.Context) (*model.ProvidersConfig, error) {
	uid, _, err := validatePermission(ctx, "settings.providers.view")
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid": uid,
	}).Debug("get providers")

	config := model.ProvidersConfig{
		Enabled:     &model.ProvidersReadinessStatus{},
		Default:     &model.DefaultProvidersConfig{},
		Models:      &model.ProvidersModelsList{},
		UserDefined: make([]*model.ProviderConfig, 0),
	}

	now := time.Now()
	defaultProvidersConfig := r.ProvidersCtrl.DefaultProvidersConfig()
	for prvtype, pcfg := range defaultProvidersConfig {
		mpcfg := &model.ProviderConfig{
			Name:      string(prvtype),
			Type:      model.ProviderType(prvtype),
			Agents:    converter.ConvertProviderConfigToGqlModel(pcfg),
			CreatedAt: now,
			UpdatedAt: now,
		}

		switch prvtype {
		case provider.ProviderOpenAI:
			config.Default.Openai = mpcfg
			if models, err := openai.DefaultModels(); err == nil {
				config.Models.Openai = converter.ConvertModels(models)
			}
		case provider.ProviderAnthropic:
			config.Default.Anthropic = mpcfg
			if models, err := anthropic.DefaultModels(); err == nil {
				config.Models.Anthropic = converter.ConvertModels(models)
			}
		case provider.ProviderGemini:
			config.Default.Gemini = mpcfg
			if models, err := gemini.DefaultModels(); err == nil {
				config.Models.Gemini = converter.ConvertModels(models)
			}
		case provider.ProviderBedrock:
			config.Default.Bedrock = mpcfg
			if models, err := bedrock.DefaultModels(); err == nil {
				config.Models.Bedrock = converter.ConvertModels(models)
			}
		case provider.ProviderOllama:
			config.Default.Ollama = mpcfg
		case provider.ProviderCustom:
			config.Default.Custom = mpcfg
		}
	}

	defaultProviders := r.ProvidersCtrl.DefaultProviders()
	for _, prvtype := range defaultProviders.ListTypes() {
		switch prvtype {
		case provider.ProviderOpenAI:
			config.Enabled.Openai = true
		case provider.ProviderAnthropic:
			config.Enabled.Anthropic = true
		case provider.ProviderGemini:
			config.Enabled.Gemini = true
		case provider.ProviderBedrock:
			config.Enabled.Bedrock = true
		case provider.ProviderOllama:
			config.Enabled.Ollama = true
			if p, ok := defaultProviders[provider.DefaultProviderNameOllama]; ok {
				config.Models.Ollama = converter.ConvertModels(p.GetModels())
			}
		case provider.ProviderCustom:
			config.Enabled.Custom = true
			if p, ok := defaultProviders[provider.DefaultProviderNameCustom]; ok {
				config.Models.Custom = converter.ConvertModels(p.GetModels())
			}
		}
	}

	providers, err := r.DB.GetUserProviders(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("failed to get user providers: %w", err)
	}

	for _, prv := range providers {
		var cfg pconfig.ProviderConfig

		if len(prv.Config) == 0 {
			prv.Config = []byte("{}")
		}
		if err := json.Unmarshal(prv.Config, &cfg); err != nil {
			r.Logger.WithError(err).Errorf("failed to unmarshal provider config: %s", prv.Config)
			continue
		}

		config.UserDefined = append(config.UserDefined, converter.ConvertProvider(prv, &cfg))
	}

	return &config, nil
}

// SettingsPrompts is the resolver for the settingsPrompts field.
func (r *queryResolver) SettingsPrompts(ctx context.Context) (*model.PromptsConfig, error) {
	uid, _, err := validatePermission(ctx, "settings.prompts.view")
	if err != nil {
		return nil, err
	}

	r.Logger.WithFields(logrus.Fields{
		"uid": uid,
	}).Debug("get prompts")

	prompts, err := r.DB.GetUserPrompts(ctx, uid)
	if err != nil {
		return nil, err
	}

	defaultPrompts, err := templates.GetDefaultPrompts()
	if err != nil {
		return nil, err
	}

	promptsConfig := model.PromptsConfig{
		Default:     converter.ConvertDefaultPrompts(defaultPrompts),
		UserDefined: make([]*model.UserPrompt, 0, len(prompts)),
	}

	for _, prompt := range prompts {
		promptsConfig.UserDefined = append(promptsConfig.UserDefined, converter.ConvertPrompt(prompt))
	}

	return &promptsConfig, nil
}

// FlowCreated is the resolver for the flowCreated field.
func (r *subscriptionResolver) FlowCreated(ctx context.Context) (<-chan *model.Flow, error) {
	uid, admin, err := validatePermission(ctx, "flows.subscribe")
	if err != nil {
		return nil, err
	}

	subscriber := r.Subscriptions.NewFlowSubscriber(uid, 0)
	if admin {
		return subscriber.FlowCreatedAdmin(ctx)
	}

	return subscriber.FlowCreated(ctx)
}

// FlowDeleted is the resolver for the flowDeleted field.
func (r *subscriptionResolver) FlowDeleted(ctx context.Context) (<-chan *model.Flow, error) {
	uid, admin, err := validatePermission(ctx, "flows.subscribe")
	if err != nil {
		return nil, err
	}

	subscriber := r.Subscriptions.NewFlowSubscriber(uid, 0)
	if admin {
		return subscriber.FlowDeletedAdmin(ctx)
	}

	return subscriber.FlowDeleted(ctx)
}

// FlowUpdated is the resolver for the flowUpdated field.
func (r *subscriptionResolver) FlowUpdated(ctx context.Context) (<-chan *model.Flow, error) {
	uid, admin, err := validatePermission(ctx, "flows.subscribe")
	if err != nil {
		return nil, err
	}

	subscriber := r.Subscriptions.NewFlowSubscriber(uid, 0)
	if admin {
		return subscriber.FlowUpdatedAdmin(ctx)
	}

	return subscriber.FlowUpdated(ctx)
}

// TaskCreated is the resolver for the taskCreated field.
func (r *subscriptionResolver) TaskCreated(ctx context.Context, flowID int64) (<-chan *model.Task, error) {
	uid, err := validatePermissionWithFlowID(ctx, "tasks.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).TaskCreated(ctx)
}

// TaskUpdated is the resolver for the taskUpdated field.
func (r *subscriptionResolver) TaskUpdated(ctx context.Context, flowID int64) (<-chan *model.Task, error) {
	uid, err := validatePermissionWithFlowID(ctx, "tasks.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).TaskUpdated(ctx)
}

// AssistantCreated is the resolver for the assistantCreated field.
func (r *subscriptionResolver) AssistantCreated(ctx context.Context, flowID int64) (<-chan *model.Assistant, error) {
	uid, err := validatePermissionWithFlowID(ctx, "assistants.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).AssistantCreated(ctx)
}

// AssistantUpdated is the resolver for the assistantUpdated field.
func (r *subscriptionResolver) AssistantUpdated(ctx context.Context, flowID int64) (<-chan *model.Assistant, error) {
	uid, err := validatePermissionWithFlowID(ctx, "assistants.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).AssistantUpdated(ctx)
}

// AssistantDeleted is the resolver for the assistantDeleted field.
func (r *subscriptionResolver) AssistantDeleted(ctx context.Context, flowID int64) (<-chan *model.Assistant, error) {
	uid, err := validatePermissionWithFlowID(ctx, "assistants.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).AssistantDeleted(ctx)
}

// ScreenshotAdded is the resolver for the screenshotAdded field.
func (r *subscriptionResolver) ScreenshotAdded(ctx context.Context, flowID int64) (<-chan *model.Screenshot, error) {
	uid, err := validatePermissionWithFlowID(ctx, "screenshots.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).ScreenshotAdded(ctx)
}

// TerminalLogAdded is the resolver for the terminalLogAdded field.
func (r *subscriptionResolver) TerminalLogAdded(ctx context.Context, flowID int64) (<-chan *model.TerminalLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "termlogs.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).TerminalLogAdded(ctx)
}

// MessageLogAdded is the resolver for the messageLogAdded field.
func (r *subscriptionResolver) MessageLogAdded(ctx context.Context, flowID int64) (<-chan *model.MessageLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "msglogs.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).MessageLogAdded(ctx)
}

// MessageLogUpdated is the resolver for the messageLogUpdated field.
func (r *subscriptionResolver) MessageLogUpdated(ctx context.Context, flowID int64) (<-chan *model.MessageLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "msglogs.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).MessageLogUpdated(ctx)
}

// AgentLogAdded is the resolver for the agentLogAdded field.
func (r *subscriptionResolver) AgentLogAdded(ctx context.Context, flowID int64) (<-chan *model.AgentLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "agentlogs.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).AgentLogAdded(ctx)
}

// SearchLogAdded is the resolver for the searchLogAdded field.
func (r *subscriptionResolver) SearchLogAdded(ctx context.Context, flowID int64) (<-chan *model.SearchLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "searchlogs.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).SearchLogAdded(ctx)
}

// VectorStoreLogAdded is the resolver for the vectorStoreLogAdded field.
func (r *subscriptionResolver) VectorStoreLogAdded(ctx context.Context, flowID int64) (<-chan *model.VectorStoreLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "vecstorelogs.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).VectorStoreLogAdded(ctx)
}

// AssistantLogAdded is the resolver for the assistantLogAdded field.
func (r *subscriptionResolver) AssistantLogAdded(ctx context.Context, flowID int64) (<-chan *model.AssistantLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "assistantlogs.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).AssistantLogAdded(ctx)
}

// AssistantLogUpdated is the resolver for the assistantLogUpdated field.
func (r *subscriptionResolver) AssistantLogUpdated(ctx context.Context, flowID int64) (<-chan *model.AssistantLog, error) {
	uid, err := validatePermissionWithFlowID(ctx, "assistantlogs.subscribe", flowID, r.DB)
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, flowID).AssistantLogUpdated(ctx)
}

// ProviderCreated is the resolver for the providerCreated field.
func (r *subscriptionResolver) ProviderCreated(ctx context.Context) (<-chan *model.ProviderConfig, error) {
	uid, _, err := validatePermission(ctx, "settings.providers.subscribe")
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, 0).ProviderCreated(ctx)
}

// ProviderUpdated is the resolver for the providerUpdated field.
func (r *subscriptionResolver) ProviderUpdated(ctx context.Context) (<-chan *model.ProviderConfig, error) {
	uid, _, err := validatePermission(ctx, "settings.providers.subscribe")
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, 0).ProviderUpdated(ctx)
}

// ProviderDeleted is the resolver for the providerDeleted field.
func (r *subscriptionResolver) ProviderDeleted(ctx context.Context) (<-chan *model.ProviderConfig, error) {
	uid, _, err := validatePermission(ctx, "settings.providers.subscribe")
	if err != nil {
		return nil, err
	}

	return r.Subscriptions.NewFlowSubscriber(uid, 0).ProviderDeleted(ctx)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
